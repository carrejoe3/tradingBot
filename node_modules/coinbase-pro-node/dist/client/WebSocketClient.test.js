"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("ws");
const BTC_USD_json_1 = __importDefault(require("../test/fixtures/ws/ticker/BTC-USD.json"));
const BTC_USD_json_2 = __importDefault(require("../test/fixtures/ws/matches/BTC-USD.json"));
const unsubscribe_success_json_1 = __importDefault(require("../test/fixtures/ws/ticker/unsubscribe-success.json"));
const WebSocketClient_1 = require("./WebSocketClient");
const reconnecting_websocket_1 = __importDefault(require("reconnecting-websocket"));
const WEBSOCKET_PORT = 8087;
const WEBSOCKET_URL = `ws://localhost:${WEBSOCKET_PORT}`;
let server;
describe('WebSocketClient', () => {
    beforeEach(done => {
        server = new WebSocket.Server({ port: WEBSOCKET_PORT });
        server.on('listening', () => done());
    });
    afterEach(done => {
        if (server) {
            server.close(error => {
                if (error) {
                    done.fail(error);
                }
                else {
                    done();
                }
            });
        }
        else {
            done();
        }
    });
    describe('constructor', () => {
        it('it signals an event when the WebSocket connection is established', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            client.on(WebSocketClient_1.WebSocketEvent.ON_OPEN, () => done());
            client.connect();
        }));
    });
    describe('subscribe', () => {
        it('receives typed messages from "ticker" channel', (done) => __awaiter(void 0, void 0, void 0, function* () {
            server.on('connection', ws => {
                ws.on('message', (message) => {
                    const request = JSON.parse(message);
                    let response;
                    if (request.type === WebSocketClient_1.WebSocketRequestType.SUBSCRIBE) {
                        response = JSON.stringify(BTC_USD_json_1.default);
                    }
                    if (request.type === WebSocketClient_1.WebSocketRequestType.UNSUBSCRIBE) {
                        response = JSON.stringify(unsubscribe_success_json_1.default);
                    }
                    server.clients.forEach(client => {
                        client.send(response);
                    });
                });
            });
            const productIds = ['BTC-USD'];
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            client.on(WebSocketClient_1.WebSocketEvent.ON_MESSAGE_TICKER, tickerMessage => {
                expect(tickerMessage.trade_id).toBe(3526965);
                client.unsubscribe([
                    {
                        name: WebSocketClient_1.WebSocketChannelName.TICKER,
                        product_ids: productIds,
                    },
                ]);
            });
            client.on(WebSocketClient_1.WebSocketEvent.ON_MESSAGE, event => {
                if (event.type === WebSocketClient_1.WebSocketResponseType.SUBSCRIPTIONS) {
                    done();
                }
            });
            client.connect();
            client.subscribe([
                {
                    name: WebSocketClient_1.WebSocketChannelName.TICKER,
                    product_ids: productIds,
                },
            ]);
        }));
        it('receives typed messages from "matches" channel', (done) => __awaiter(void 0, void 0, void 0, function* () {
            server.on('connection', ws => {
                ws.on('message', (message) => {
                    const request = JSON.parse(message);
                    let response;
                    if (request.type === WebSocketClient_1.WebSocketRequestType.SUBSCRIBE) {
                        response = JSON.stringify(BTC_USD_json_2.default);
                    }
                    if (request.type === WebSocketClient_1.WebSocketRequestType.UNSUBSCRIBE) {
                        response = JSON.stringify(unsubscribe_success_json_1.default);
                    }
                    server.clients.forEach(client => {
                        client.send(response);
                    });
                });
            });
            const productIds = ['BTC-USD'];
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            client.on(WebSocketClient_1.WebSocketEvent.ON_MESSAGE_MATCHES, message => {
                expect(message.trade_id).toBe(9713921);
                client.unsubscribe([
                    {
                        name: WebSocketClient_1.WebSocketChannelName.MATCHES,
                        product_ids: productIds,
                    },
                ]);
            });
            client.on(WebSocketClient_1.WebSocketEvent.ON_MESSAGE, event => {
                if (event.type === WebSocketClient_1.WebSocketResponseType.SUBSCRIPTIONS) {
                    done();
                }
            });
            client.connect();
            client.subscribe([
                {
                    name: WebSocketClient_1.WebSocketChannelName.MATCHES,
                    product_ids: productIds,
                },
            ]);
        }));
    });
    describe('connect', () => {
        it('attaches an error listener', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const invalidUrl = 'ws://localhost:50001';
            const client = new WebSocketClient_1.WebSocketClient(invalidUrl);
            client.on(WebSocketClient_1.WebSocketEvent.ON_ERROR, done);
            client.connect();
        }));
        it('throws an error when trying to overwrite an existing connection', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            client.connect();
            try {
                client.connect();
                done.fail('No error has been thrown');
            }
            catch (error) {
                done();
            }
        }));
        it('supports custom reconnect options', () => __awaiter(void 0, void 0, void 0, function* () {
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            const socket = client.connect({ startClosed: true });
            expect(socket.readyState).toBe(reconnecting_websocket_1.default.CLOSED);
        }));
    });
    describe('disconnect', () => {
        it('does not do anything if there is no existing connection', () => {
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            const onClose = jasmine.createSpy('onClose');
            client.on(WebSocketClient_1.WebSocketEvent.ON_CLOSE, () => {
                onClose();
            });
            client.disconnect();
            expect(onClose).not.toHaveBeenCalled();
        });
        it('emits an event when an existing connection gets closed', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            client.on(WebSocketClient_1.WebSocketEvent.ON_CLOSE, () => {
                done();
            });
            client.on(WebSocketClient_1.WebSocketEvent.ON_OPEN, () => {
                client.disconnect();
            });
            client.connect();
        }));
    });
    describe('sendMessage', () => {
        it('does not send a message when there is no active connection', () => {
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            expect(() => {
                client.sendMessage({
                    channels: [WebSocketClient_1.WebSocketChannelName.HEARTBEAT],
                    type: WebSocketClient_1.WebSocketRequestType.UNSUBSCRIBE,
                });
            }).toThrow();
        });
        it('supports authenticated subscriptions', (done) => __awaiter(void 0, void 0, void 0, function* () {
            server.on('connection', ws => {
                ws.on('message', (message) => {
                    const request = JSON.parse(message);
                    expect(request.passphrase).toBeDefined();
                    expect(request.signature).toBeDefined();
                    expect(request.key).toBeDefined();
                    done();
                });
            });
            const message = {
                channels: [
                    {
                        name: WebSocketClient_1.WebSocketChannelName.LEVEL2,
                        product_ids: ['ETH-USD', 'ETH-EUR'],
                    },
                ],
                type: WebSocketClient_1.WebSocketRequestType.SUBSCRIBE,
            };
            const signature = {
                key: 'a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1',
                passphrase: 'a1a1a1a1a1a',
                signature: 'A1A1A1a1a1a1a1a1A1a1A1A1A1a1a1A1a1111aaa1AA=',
                timestamp: 1557702240.0149999,
            };
            const client = new WebSocketClient_1.WebSocketClient(WEBSOCKET_URL);
            client.on(WebSocketClient_1.WebSocketEvent.ON_OPEN, () => {
                client.sendMessage(message, signature);
            });
            client.connect();
        }));
    });
});
//# sourceMappingURL=WebSocketClient.test.js.map