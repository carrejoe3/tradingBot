"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const reconnecting_websocket_1 = __importDefault(require("reconnecting-websocket"));
const ws_1 = __importDefault(require("ws"));
var WebSocketChannelName;
(function (WebSocketChannelName) {
    WebSocketChannelName["FULL"] = "full";
    WebSocketChannelName["HEARTBEAT"] = "heartbeat";
    WebSocketChannelName["LEVEL2"] = "level2";
    WebSocketChannelName["MATCHES"] = "matches";
    WebSocketChannelName["STATUS"] = "status";
    WebSocketChannelName["TICKER"] = "ticker";
    WebSocketChannelName["USER"] = "user";
})(WebSocketChannelName = exports.WebSocketChannelName || (exports.WebSocketChannelName = {}));
var WebSocketRequestType;
(function (WebSocketRequestType) {
    WebSocketRequestType["SUBSCRIBE"] = "subscribe";
    WebSocketRequestType["UNSUBSCRIBE"] = "unsubscribe";
})(WebSocketRequestType = exports.WebSocketRequestType || (exports.WebSocketRequestType = {}));
var WebSocketResponseType;
(function (WebSocketResponseType) {
    WebSocketResponseType["ERROR"] = "error";
    WebSocketResponseType["SUBSCRIPTIONS"] = "subscriptions";
    WebSocketResponseType["HEARTBEAT"] = "heartbeat";
    WebSocketResponseType["STATUS"] = "status";
    WebSocketResponseType["TICKER"] = "ticker";
    WebSocketResponseType["LEVEL2_SNAPSHOT"] = "snapshot";
    WebSocketResponseType["LEVEL2_UPDATE"] = "l2update";
    WebSocketResponseType["FULL_RECEIVED"] = "received";
    WebSocketResponseType["FULL_OPEN"] = "open";
    WebSocketResponseType["FULL_DONE"] = "done";
    WebSocketResponseType["FULL_MATCH"] = "match";
    WebSocketResponseType["FULL_CHANGE"] = "change";
    WebSocketResponseType["FULL_ACTIVATE"] = "activate";
    WebSocketResponseType["LAST_MATCH"] = "last_match";
})(WebSocketResponseType = exports.WebSocketResponseType || (exports.WebSocketResponseType = {}));
var WebSocketEvent;
(function (WebSocketEvent) {
    WebSocketEvent["ON_CLOSE"] = "WebSocketEvent.ON_CLOSE";
    WebSocketEvent["ON_ERROR"] = "WebSocketEvent.ON_ERROR";
    WebSocketEvent["ON_MESSAGE"] = "WebSocketEvent.ON_MESSAGE";
    WebSocketEvent["ON_MESSAGE_MATCHES"] = "WebSocketEvent.ON_MESSAGE_MATCHES";
    WebSocketEvent["ON_MESSAGE_TICKER"] = "WebSocketEvent.ON_MESSAGE_TICKER";
    WebSocketEvent["ON_OPEN"] = "WebSocketEvent.ON_OPEN";
    WebSocketEvent["ON_SUBSCRIPTION_UPDATE"] = "WebSocketEvent.ON_SUBSCRIPTION_UPDATE";
})(WebSocketEvent = exports.WebSocketEvent || (exports.WebSocketEvent = {}));
class WebSocketClient extends events_1.EventEmitter {
    constructor(baseURL) {
        super();
        this.baseURL = baseURL;
    }
    connect(reconnectOptions) {
        if (this.socket) {
            throw Error(`You established already a WebSocket connection. Please call "disconnect" first before creating a new one.`);
        }
        const options = this.mergeOptions(reconnectOptions);
        this.socket = new reconnecting_websocket_1.default(this.baseURL, [], options);
        this.socket.onclose = (event) => {
            this.emit(WebSocketEvent.ON_CLOSE, event);
        };
        this.socket.onerror = (event) => {
            this.emit(WebSocketEvent.ON_ERROR, event);
        };
        this.socket.onmessage = (event) => {
            const response = JSON.parse(event.data);
            this.emit(WebSocketEvent.ON_MESSAGE, response);
            switch (response.type) {
                case WebSocketResponseType.SUBSCRIPTIONS:
                    this.emit(WebSocketEvent.ON_SUBSCRIPTION_UPDATE, response);
                    break;
                case WebSocketResponseType.TICKER:
                    this.emit(WebSocketEvent.ON_MESSAGE_TICKER, response);
                    break;
                case WebSocketResponseType.FULL_MATCH:
                case WebSocketResponseType.LAST_MATCH:
                    this.emit(WebSocketEvent.ON_MESSAGE_MATCHES, response);
                    break;
            }
        };
        this.socket.onopen = () => {
            this.emit(WebSocketEvent.ON_OPEN);
        };
        return this.socket;
    }
    disconnect(reason = 'Unknown reason') {
        if (this.socket) {
            this.socket.close(WebSocketClient.CLOSE_EVENT_CODE.NORMAL_CLOSURE, reason);
            this.socket = undefined;
        }
    }
    sendMessage(message, signature) {
        if (!this.socket) {
            throw new Error(`Failed to send message of type "${message.type}": You need to connect to the WebSocket first.`);
        }
        if (signature) {
            Object.assign(message, signature);
        }
        this.socket.send(JSON.stringify(message));
    }
    subscribe(channels) {
        this.sendMessage({
            channels,
            type: WebSocketRequestType.SUBSCRIBE,
        });
    }
    unsubscribe(channels) {
        this.sendMessage({
            channels,
            type: WebSocketRequestType.UNSUBSCRIBE,
        });
    }
    mergeOptions(reconnectOptions) {
        const defaultOptions = {
            WebSocket: ws_1.default,
            connectionTimeout: 2000,
            debug: false,
            maxReconnectionDelay: 4000,
            maxRetries: Infinity,
            minReconnectionDelay: 1000,
            reconnectionDelayGrowFactor: 1,
        };
        return Object.assign(Object.assign({}, defaultOptions), reconnectOptions);
    }
}
exports.WebSocketClient = WebSocketClient;
WebSocketClient.CLOSE_EVENT_CODE = {
    GOING_AWAY: 1001,
    NORMAL_CLOSURE: 1000,
    PROTOCOL_ERROR: 1002,
    UNSUPPORTED_DATA: 1003,
};
//# sourceMappingURL=WebSocketClient.js.map