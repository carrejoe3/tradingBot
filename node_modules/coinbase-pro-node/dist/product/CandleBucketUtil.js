"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const MAXIMUM_HISTORIC_DATA_POINTS = 300;
class CandleBucketUtil {
    static getIntervals() {
        return [60, 300, 900, 3600, 21600, 86400];
    }
    static mapInterval(intervals, interval) {
        return intervals.reduce((previous, current) => {
            return Math.abs(current - interval) < Math.abs(previous - interval) ? current : previous;
        });
    }
    static mapGranularity(candleSizeInMillis) {
        return this.mapInterval(CandleBucketUtil.getIntervals(), candleSizeInMillis);
    }
    static expectedBuckets(fromInMillis, toInMillis, candleSizeInMillis) {
        const timeSpanInMillis = toInMillis - fromInMillis;
        return timeSpanInMillis / candleSizeInMillis;
    }
    static getBucketsInMillis(fromInMillis, toInMillis, candleSizeInMillis) {
        const bucketsInMillis = [];
        const batch = MAXIMUM_HISTORIC_DATA_POINTS * candleSizeInMillis;
        let current = fromInMillis;
        bucketsInMillis.push(current);
        current = current + batch;
        while (current < toInMillis) {
            bucketsInMillis.push(current - 1);
            bucketsInMillis.push(current);
            current = current + batch;
        }
        bucketsInMillis.push(toInMillis);
        return bucketsInMillis;
    }
    static getBucketsInISO(bucketsInMillis) {
        const bucketsInISO = [];
        for (let i = 0; i < bucketsInMillis.length - 1; i += 2) {
            const start = new Date(bucketsInMillis[i]).toISOString();
            const stop = new Date(bucketsInMillis[i + 1]).toISOString();
            bucketsInISO.push({
                start,
                stop,
            });
        }
        return bucketsInISO;
    }
}
exports.CandleBucketUtil = CandleBucketUtil;
//# sourceMappingURL=CandleBucketUtil.js.map